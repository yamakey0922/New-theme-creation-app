<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>材料研究開発戦略 AIディスカッション</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- marked.js CDN (Markdownパーサー) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Font Awesome CDN (アイコン) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <!-- スタイル定義 -->
    <style>
        /* Interフォントの読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            display: flex; /* APIキー画面を中央寄せするため */
            flex-direction: column;
            height: 100vh;
        }

        /* チャットインターフェースが有効になったら高さを戻す */
        body.chat-active {
            display: block;
        }

        /* APIキー入力画面 */
        #api-key-screen {
            flex-grow: 1; /* 画面全体に広げる */
        }

        /* カスタムスクロールバー */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }
        #chat-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* coolGray-100 */
        }
        #chat-container::-webkit-scrollbar-thumb {
            background: #94a3b8; /* coolGray-400 */
            border-radius: 4px;
        }
        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* coolGray-500 */
        }
        
        /* レポートモーダルのスクロールバー */
        #report-content::-webkit-scrollbar {
            width: 6px;
        }
        #report-content::-webkit-scrollbar-track {
            background: #f8fafc; /* coolGray-50 */
        }
        #report-content::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* coolGray-300 */
            border-radius: 3px;
        }

        /* チャットバブルのスタイル */
        .chat-bubble {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        .chat-technician {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            border-bottom-right-radius: 0.25rem;
            align-self: flex-end;
        }

        .chat-chatgpt {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
            border-bottom-left-radius: 0.25rem;
            align-self: flex-start;
        }

        .chat-gemini {
            background-color: #f3e8ff; /* purple-100 */
            color: #1f2937; /* gray-800 */
            border-bottom-left-radius: 0.25rem;
            align-self: flex-start;
        }
        
        /* レポート内のMarkdownスタイル */
        #report-output h1 { font-size: 1.5rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.25rem; }
        #report-output h2 { font-size: 1.25rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; }
        #report-output h3 { font-size: 1.1rem; font-weight: 600; margin-top: 0.75rem; margin-bottom: 0.25rem; }
        #report-output ul { list-style-type: disc; margin-left: 1.5rem; margin-bottom: 0.5rem; }
        #report-output ol { list-style-type: decimal; margin-left: 1.5rem; margin-bottom: 0.5rem; }
        #report-output p { margin-bottom: 0.5rem; }
        #report-output strong { font-weight: 600; }
        #report-output code { background-color: #f3f4f6; padding: 0.1rem 0.25rem; border-radius: 0.25rem; font-family: monospace; }
        
        /* マイクボタンの録音中アニメーション */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }
        .recording {
            animation: pulse 1.5s infinite;
            background-color: #ef4444; /* red-500 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 antialiased">

    <!-- APIキー入力画面 -->
    <div id="api-key-screen" class="flex flex-col items-center justify-center w-full h-full p-4 bg-gray-100">
        <div class="w-full max-w-md p-8 bg-white rounded-lg shadow-xl border border-gray-200">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">
                <i class="fa-solid fa-key text-blue-500"></i>
                APIキーを入力
            </h2>
            <p class="text-sm text-gray-600 mb-6 text-center">
                議論を開始するには、APIキーを入力してください。<br>
                <span class="font-semibold text-gray-700">(注: この環境ではGemini APIキーは自動供給されますが、入力が必須です)</span>
            </p>
            
            <form id="api-key-form" class="space-y-4">
                <div>
                    <label for="chatgpt-api-key" class="block text-sm font-medium text-gray-700 mb-1">
                        ChatGPT APIキー (シミュレート用)
                    </label>
                    <input type="password" id="chatgpt-api-key" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-green-500" placeholder="sk-...">
                </div>
                
                <div>
                    <label for="gemini-api-key" class="block text-sm font-medium text-gray-700 mb-1">
                        Gemini APIキー (通信用)
                    </label>
                    <input type="password" id="gemini-api-key" class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500" placeholder="AIzaSy...">
                </div>
                
                <p id="api-error" class="text-red-500 text-sm text-center hidden pt-2">
                    両方のAPIキーを入力してください。
                </p>

                <button type="submit" id="start-button" class="w-full bg-blue-500 text-white font-semibold py-3 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200">
                    議論を開始する
                    <i class="fa-solid fa-arrow-right ml-2"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- チャットインターフェース (デフォルトは非表示) -->
    <div id="chat-interface" class="hidden flex-col h-screen">
        <!-- ヘッダー -->
        <header class="bg-white shadow-md w-full p-4 border-b border-gray-200">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800 text-center">
                <i class="fa-solid fa-flask-vial text-blue-500"></i>
                材料研究開発戦略 AIディスカッション
            </h1>
        </header>

        <!-- メインコンテンツ (チャットエリア + 入力エリア) -->
        <main class="flex-1 flex flex-col overflow-hidden p-4 md:p-6 lg:p-8">
            
            <!-- チャットコンテナ -->
            <div id="chat-container" class="flex-1 overflow-y-auto bg-white p-4 md:p-6 rounded-lg shadow-inner border border-gray-200 flex flex-col space-y-4">
                <!-- チャットメッセージがここに追加されます -->
            </div>

            <!-- ローディングインジケーター -->
            <div id="loading-indicator" class="hidden text-center p-4 items-center justify-center space-x-2 text-gray-500">
                <svg class="animate-spin h-5 w-5 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>AIが応答を生成中です...</span>
            </div>
            
            <!-- マイクステータス -->
            <div id="mic-status" class="hidden text-center p-2 text-red-500 font-medium">
                <i class="fa-solid fa-microphone-lines animate-pulse"></i> 録音中...
            </div>

            <!-- 入力エリア -->
            <div class="bg-white p-4 md:p-6 mt-4 rounded-lg shadow-md border border-gray-200">
                <div class="flex items-start space-x-2 md:space-x-4">
                    <textarea id="message-input" rows="3" class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none" placeholder="議論したい内容、または『議論終了』と入力してください..."></textarea>
                    
                    <button id="send-button" title="送信" class="p-3 h-full bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fa-solid fa-paper-plane fa-fw"></i>
                    </button>
                    
                    <button id="mic-button" title="音声入力" class="p-3 h-full bg-gray-600 text-white rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i id="mic-icon" class="fa-solid fa-microphone fa-fw"></i>
                    </button>
                </div>
            </div>
        </main>
    </div>
    
    <!-- レポート生成モーダル -->
    <div id="report-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl h-full max-h-[90vh] flex flex-col">
            <!-- モーダルヘッダー -->
            <div class="flex justify-between items-center p-5 border-b border-gray-200">
                <h2 class="text-xl font-semibold text-gray-800">
                    <i class="fa-solid fa-file-alt text-purple-600"></i>
                    戦略サマリーレポート
                </h2>
                <button id="close-report-button" class="text-gray-400 hover:text-gray-600 focus:outline-none">
                    <i class="fa-solid fa-times fa-xl"></i>
                </button>
            </div>
            
            <!-- モーダルコンテンツ -->
            <div id="report-content" class="flex-1 p-6 overflow-y-auto">
                <div id="report-loading" class="text-center py-10">
                    <svg class="animate-spin h-8 w-8 text-purple-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p class="mt-4 text-gray-600 font-medium">Geminiが議論を分析し、レポートを作成しています...</p>
                </div>
                <!-- レポート内容がここに挿入されます -->
                <div id="report-output" class="prose max-w-none"></div>
            </div>
            
            <!-- モーダル フッター -->
            <div class="p-4 border-t border-gray-200 bg-gray-50 rounded-b-lg">
                <p class="text-sm text-gray-500 text-center">
                    <i class="fa-solid fa-lightbulb"></i>
                    このレポートはAIによって生成されました。
                </p>
            </div>
        </div>
    </div>


    <!-- JavaScript -->
    <script type="module">
        // ----------------------------------------
        // グローバル変数と設定
        // ----------------------------------------
        
        // APIキー画面
        const apiKeyScreen = document.getElementById('api-key-screen');
        const apiKeyForm = document.getElementById('api-key-form');
        const chatGptApiKeyInput = document.getElementById('chatgpt-api-key');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const apiError = document.getElementById('api-error');

        // チャット画面
        const chatInterface = document.getElementById('chat-interface');
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const micIcon = document.getElementById('mic-icon');
        const micStatus = document.getElementById('mic-status');
        const loadingIndicator = document.getElementById('loading-indicator');
        
        // レポートモーダル
        const reportModal = document.getElementById('report-modal');
        const closeReportButton = document.getElementById('close-report-button');
        const reportLoading = document.getElementById('report-loading');
        const reportOutput = document.getElementById('report-output');

        // Gemini API設定
        // この環境では、apiKeyは空文字列のままにしておくと自動的に提供されます。
        const apiKey = ""; 
        // ユーザーが入力したキーはUIの動作のために「使用」しますが、
        // 実際のAPI URLにはこの自動供給されるキーを使います。
        const genAIApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // チャット履歴
        let uiHistory = [];
        let apiHistory = [];
        
        let isAIBusy = false; // AIの応答中フラグ
        let isRecording = false; // 録音中フラグ

        // Web Speech API (音声認識) の設定
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        
        // ブラウザが音声認識をサポートしているかチェック
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP'; // 言語を日本語に設定
            recognition.interimResults = false; // 途中の結果は不要
            recognition.continuous = false; // 単一の発話
            
            // 音声認識の結果が得られたとき
            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value = transcript;
                stopRecording();
            };

            // 音声認識が終了したとき
            recognition.onend = () => {
                if (isRecording) {
                    stopRecording();
                }
            };
            
            // エラーが発生したとき
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                micStatus.textContent = `エラー: ${event.error}`;
                micStatus.classList.remove('hidden');
                setTimeout(() => micStatus.classList.add('hidden'), 3000);
                stopRecording();
            };

        } else {
            console.warn('Speech Recognition API is not supported in this browser.');
            micButton.disabled = true;
            micButton.title = "お使いのブラウザは音声認識をサポートしていません";
        }

        // ----------------------------------------
        // システムプロンプト (ペルソナ定義)
        // ----------------------------------------
        const systemPromptChatGPT = {
            parts: [{ text: `
あなたは、材料研究開発の「シーズドリブン」担当AIアシスタント「ChatGPT」です。
あなたの役割は以下の通りです。

1.  **先端研究の分析:** 技術者から指定された材料領域について、最新の先端研究、先行研究、科学的エビデンスを収集・分析します。
2.  **研究経緯の整理:** その最新研究に至った経緯や、技術的なブレークスルーのポイントを明確に整理します。
3.  **トピックスの提案:** 技術者が提供する「社内の強み（既存技術、設備、ノウハウ）」を理解し、それを活用できそうな新しい研究トピックスを具体的に提案します。
4.  **議論の促進:** 常に科学的根拠に基づき、シーズ（技術の種）の観点から議論をリードしてください。
`}]
        };

        const systemPromptGemini = {
            parts: [{ text: `
あなたは、材料研究開発の「ニーズドリブン」担当AIアシスタント「Gemini」です。
あなたの役割は以下の通りです。

1.  **将来ニーズの具体化:** 技術者が提示する概念的な将来像やビジョンを深掘りします。
2.  **市場・環境分析:** 世界中の技術ロードマップ、市場動向、自然環境（例：規制、SDGs）、社会環境（例：高齢化、ライフスタイル変化）、地理的状況などを幅広く分析します。
3.  **出口戦略の明確化:** 上記の分析に基づき、開発される技術の具体的な「使われ方」、ターゲットとなる「想定顧客」、そして彼らが抱える「本質的な課題（ニーズ）」を明確にします。
4.  **議論の促進:** 常に市場と顧客の視点に立ち、ニーズ（出口）の観点から議論をリードしてください。
`}]
        };

        const systemPromptReport = {
            parts: [{ text: `
あなたは、優秀な技術戦略コンサルタントです。
あなたの役割は、以下の「技術者」「ChatGPT（シーズ担当）」「Gemini（ニーズ担当）」の三者による議論の全履歴を詳細に分析することです。

分析に基づき、以下の3つのセクションで構成される詳細な「戦略サマリーレポート」を作成してください。

1.  **議論の要約:**
    * 議論全体の流れと、主要な論点を時系列で簡潔にまとめてください。
    * 各参加者（技術者、ChatGPT、Gemini）の重要な貢献や指摘事項を明確にしてください。

2.  **新テーマ・新プロジェクトの提案:**
    * 議論（シーズ、ニーズ、社の強み）から導き出される、具体的かつ実行可能性のある「新研究テーマ」または「新プロジェクト」を複数提案してください。
    * 各提案について、その背景（どの議論に基づいているか）、目的、期待される成果を明確に記述してください。

3.  **これからの進め方（ネクストステップ）:**
    * 提案されたテーマ/プロジェクトを推進するために、明日から取るべき具体的なアクションプランを提案してください。
    * （例：追加の市場調査、特定の先行研究の深掘り、必要なリソース（人材、設備）の特定、初期実験計画の立案など）

レポートは、経営層や研究開発リーダーが意思決定できるように、プロフェッショナルかつ論理的な構成で記述してください。
`}]
        };

        // ----------------------------------------
        // イベントリスナー
        // ----------------------------------------
        
        // ページ読み込み完了時 (APIキー入力画面の処理)
        window.addEventListener('load', () => {
            // ローカルストレージからキーを読み込む（もしあれば）
            const savedGptKey = localStorage.getItem('chatgptApiKey');
            const savedGeminiKey = localStorage.getItem('geminiApiKey');
            if (savedGptKey) chatGptApiKeyInput.value = savedGptKey;
            if (savedGeminiKey) geminiApiKeyInput.value = savedGeminiKey;
        });

        // APIキーフォーム送信（議論開始）
        apiKeyForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const gptKey = chatGptApiKeyInput.value.trim();
            const geminiKey = geminiApiKeyInput.value.trim();

            if (gptKey && geminiKey) {
                // キーをローカルストレージに保存
                localStorage.setItem('chatgptApiKey', gptKey);
                localStorage.setItem('geminiApiKey', geminiKey);
                
                // 画面切り替え
                apiKeyScreen.classList.add('hidden');
                chatInterface.classList.remove('hidden');
                chatInterface.classList.add('flex');
                document.body.classList.add('chat-active'); // bodyのスタイルを戻す

                // チャット初期化（最初の挨拶）
                initializeChat();
            } else {
                // エラー表示
                apiError.classList.remove('hidden');
            }
        });

        // (チャット画面のイベントリスナー)

        // 送信ボタン
        sendButton.addEventListener('click', handleUserInput);
        
        // Enterキーで送信 (Shift+Enterで改行)
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleUserInput();
            }
        });

        // マイクボタン
        micButton.addEventListener('click', () => {
            if (!recognition) return;
            
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        // レポートモーダルを閉じる
        closeReportButton.addEventListener('click', () => {
            reportModal.classList.add('hidden');
        });

        // ----------------------------------------
        // チャット初期化
        // ----------------------------------------

        function initializeChat() {
            // 最初の挨拶メッセージ
            const firstMessage = "技術者の方、こんにちは。私はシーズドリブン担当のChatGPTです。";
            const secondMessage = "私はニーズドリブン担当のGeminiです。本日はどの材料研究開発領域について議論を開始しますか？ 具体的な領域を教えてください。";
            
            addMessageToUI('ChatGPT', firstMessage);
            uiHistory.push({ speaker: 'ChatGPT', text: firstMessage });
            
            // API履歴の初期化
            apiHistory.push({ role: 'user', parts: [{ text: "議論を開始してください。" }] });
            apiHistory.push({ role: 'model', parts: [{ text: firstMessage }] });

            setTimeout(() => {
                addMessageToUI('Gemini', secondMessage);
                uiHistory.push({ speaker: 'Gemini', text: secondMessage });
                // 直前のmodelの応答に結合
                apiHistory[apiHistory.length - 1].parts[0].text += `\n\n${secondMessage}`;
            }, 1000); // 少し遅らせて表示
        }


        // ----------------------------------------
        // 音声認識ヘルパー
        // ----------------------------------------
        
        function startRecording() {
            if (isAIBusy) return; // AI応答中は録音しない
            try {
                recognition.start();
                isRecording = true;
                micButton.classList.add('recording');
                micIcon.classList.remove('fa-microphone');
                micIcon.classList.add('fa-stop');
                micStatus.textContent = "録音中...";
                micStatus.classList.remove('hidden');
                messageInput.disabled = true;
                sendButton.disabled = true;
            } catch (e) {
                console.error("Recording start error:", e);
                micStatus.textContent = "エラー: 録音を開始できませんでした。";
                micStatus.classList.remove('hidden');
                setTimeout(() => micStatus.classList.add('hidden'), 3000);
            }
        }

        function stopRecording() {
            if (!isRecording) return;
            recognition.stop();
            isRecording = false;
            micButton.classList.remove('recording');
            micIcon.classList.add('fa-microphone');
            micIcon.classList.remove('fa-stop');
            micStatus.classList.add('hidden');
            messageInput.disabled = false;
            sendButton.disabled = false;
        }

        // ----------------------------------------
        // 中核ロジック
        // ----------------------------------------
        
        /**
         * ユーザーの入力を処理
         */
        async function handleUserInput() {
            const message = messageInput.value.trim();
            if (!message || isAIBusy) return;
            
            // UI更新
            addMessageToUI('Technician', message);
            messageInput.value = '';
            setLoading(true);
            
            // 履歴更新
            uiHistory.push({ speaker: 'Technician', text: message });
            
            // API履歴を更新
            apiHistory.push({ role: 'user', parts: [{ text: message }] });


            // 終了キーワードのチェック
            const endKeywords = ['議論終了', '議論をおわる', 'おわり', 'レポート作成', '終了します'];
            if (endKeywords.some(keyword => message.includes(keyword))) {
                // 議論終了処理
                await generateReport();
                setLoading(false);
                return;
            }

            // AIの応答チェーンを開始
            // Gemini APIの制約 (最後のroleは 'user' である必要がある) への対応
            try {
                // 1. ChatGPT (シーズ) の応答
                //    apiHistory の末尾は 'user' (技術者) なので、そのまま呼べる
                const responseGpt = await callGeminiApi(systemPromptChatGPT, apiHistory, true); // Google Search有効
                addMessageToUI('ChatGPT', responseGpt);
                uiHistory.push({ speaker: 'ChatGPT', text: responseGpt });
                // apiHistoryに 'model' (ChatGPT) の応答として追加
                apiHistory.push({ role: 'model', parts: [{ text: responseGpt }] });

                // 2. Gemini (ニーズ) の応答
                //    apiHistory の末尾は 'model' (ChatGPT) になった。
                //    このままでは呼べないため、Geminiへの「架空の質問」を 'user'として追加する。
                //    これはUIには表示しない。
                const promptForGemini = {
                    role: 'user',
                    parts: [{ text: `(ChatGPTが上記のようにシーズの観点から分析しました。これを受けて、Geminiさん、ニーズドリブンの観点からあなたの分析と意見を聞かせてください。)` }]
                };
                apiHistory.push(promptForGemini);

                //    apiHistory の末尾が 'user' (架空) になったので、Geminiを呼べる
                const responseGemini = await callGeminiApi(systemPromptGemini, apiHistory, true); // Google Search有効
                addMessageToUI('Gemini', responseGemini);
                uiHistory.push({ speaker: 'Gemini', text: responseGemini });
                
                // apiHistoryに 'model' (Gemini) の応答として追加
                apiHistory.push({ role: 'model', parts: [{ text: responseGemini }] });
                
                // これで履歴は [..., user(T), model(C), user(架空), model(G)] となり、
                // 次の技術者の入力 (user) を待つ状態になる。

            } catch (error) {
                console.error("AI response chain error:", error);
                addMessageToUI('System', `エラーが発生しました: ${error.message}`);
            } finally {
                setLoading(false);
            }
        }

        /**
         * レポートを生成
         */
        async function generateReport() {
            console.log("Generating report...");
            reportModal.classList.remove('hidden');
            reportLoading.classList.remove('hidden');
            reportOutput.innerHTML = '';

            try {
                // レポート作成用のAPI履歴を作成
                
                // 最後の「議論終了」という発言は、レポート作成のトリガーであって、
                // 分析対象の議論内容そのものではない。
                // したがって、apiHistoryの最後の user メッセージを除外してAPIに渡す
                
                let historyForReport = [...apiHistory];
                if(historyForReport.length > 0 && historyForReport[historyForReport.length - 1].role === 'user') {
                    historyForReport.pop();
                }

                // historyForReport の末尾が 'model' になっていることを確認
                // (もし 'user(架空)' で終わっていたらそれも除く必要があるが、
                // 議論終了の直前は model(G) で終わっているはず)

                const reportText = await callGeminiApi(systemPromptReport, historyForReport, false); // レポート作成時はSearch不要
                
                // MarkdownをHTMLに変換して表示
                reportOutput.innerHTML = marked.parse(reportText);
                reportLoading.classList.add('hidden');

            } catch (error) {
                console.error("Report generation error:", error);
                reportOutput.innerHTML = `<p class="text-red-500">レポートの生成中にエラーが発生しました: ${error.message}</p>`;
                reportLoading.classList.add('hidden');
            }
        }

        /**
         * Gemini API 呼び出し (Exponential Backoff 付き)
         * @param {object} systemInstruction - システムプロンプト
         * @param {array} history - API用のチャット履歴 (末尾は 'user' であること)
         * @param {boolean} useGoogleSearch - Google Search を使うか
         */
        async function callGeminiApi(systemInstruction, history, useGoogleSearch = false) {
            const maxRetries = 5;
            let delay = 1000; // 1秒から開始

            // 履歴の末尾が 'user' であるか最終チェック (デバッグ用)
            if (history.length > 0 && history[history.length - 1].role !== 'user') {
                console.error("API call history error: Last role is not 'user'.", history);
                // このエラーは本番ではUIに表示すべき
                addMessageToUI('System', '内部エラー: API履歴の形式が不正です。');
                return "内部エラーが発生しました。";
            }

            const payload = {
                contents: history,
                systemInstruction: systemInstruction,
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 8192,
                }
            };

            if (useGoogleSearch) {
                payload.tools = [{ "google_search": {} }];
            }

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(genAIApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error("API Error Response:", errorText);
                        throw new Error(`APIリクエスト失敗 (ステータス: ${response.status})`);
                    }

                    const result = await response.json();
                    
                    if (result.candidates && result.candidates[0].content?.parts?.[0]?.text) {
                        return result.candidates[0].content.parts[0].text;
                    } else if (result.candidates && result.candidates[0].finishReason === "SAFETY") {
                        throw new Error("応答が安全性の設定によりブロックされました。");
                    } else {
                        console.warn("API response structure unexpected:", result);
                        throw new Error("AIからの有効な応答がありませんでした。");
                    }
                } catch (error) {
                    console.warn(`Attempt ${i + 1} failed: ${error.message}`);
                    if (i === maxRetries - 1) {
                        throw error; // 最終試行でも失敗
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // バックオフ時間を倍増
                }
            }
        }

        // ----------------------------------------
        // UI ヘルパー
        // ----------------------------------------

        /**
         * チャットUIにメッセージを追加
         * @param {'Technician' | 'ChatGPT' | 'Gemini' | 'System'} speaker
         * @param {string} message
         */
        function addMessageToUI(speaker, message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-bubble', 'flex', 'flex-col');
            
            let speakerLabel = '';
            let iconClass = '';
            let bubbleClass = '';

            switch (speaker) {
                case 'Technician':
                    bubbleClass = 'chat-technician';
                    speakerLabel = '技術者 (あなた)';
                    iconClass = 'fa-solid fa-user';
                    break;
                case 'ChatGPT':
                    bubbleClass = 'chat-chatgpt';
                    speakerLabel = 'ChatGPT (シーズ)';
                    iconClass = 'fa-solid fa-brain text-green-600';
                    break;
                case 'Gemini':
                    bubbleClass = 'chat-gemini';
                    speakerLabel = 'Gemini (ニーズ)';
                    iconClass = 'fa-solid fa-globe text-purple-600';
                    break;
                case 'System':
                    bubbleClass = 'chat-chatgpt'; // システムメッセージはChatGPT風に
                    speakerLabel = 'システム';
                    iconClass = 'fa-solid fa-exclamation-circle text-red-500';
                    break;
            }
            
            messageElement.classList.add(bubbleClass);

            // スピーカーラベルとアイコン
            const speakerElement = document.createElement('div');
            speakerElement.classList.add('flex', 'items-center', 'space-x-2', 'mb-2', 'font-semibold', 'text-sm');
            if (speaker === 'Technician') {
                 speakerElement.classList.add('text-blue-100');
            } else {
                 speakerElement.classList.add('text-gray-700');
            }

            speakerElement.innerHTML = `<i class="${iconClass}"></i><span>${speakerLabel}</span>`;
            
            // メッセージ本文 (Markdownパース)
            const contentElement = document.createElement('div');
            contentElement.classList.add('message-content');
            contentElement.innerHTML = marked.parse(message);
            
            messageElement.appendChild(speakerElement);
            messageElement.appendChild(contentElement);
            chatContainer.appendChild(messageElement);

            // 一番下にスクロール
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        /**
         * ローディング状態の設定
         * @param {boolean} isLoading
         */
        function setLoading(isLoading) {
            isAIBusy = isLoading;
            if (isLoading) {
                loadingIndicator.classList.remove('hidden');
                loadingIndicator.classList.add('flex');
                sendButton.disabled = true;
                micButton.disabled = true;
                messageInput.disabled = true;
            } else {
                loadingIndicator.classList.add('hidden');
                loadingIndicator.classList.remove('flex');
                sendButton.disabled = false;
                micButton.disabled = (recognition === undefined); // 音声認識がサポートされていれば有効化
                messageInput.disabled = false;
                messageInput.focus();
            }
        }

    </script>
</body>
</html>