<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>材料研究開発戦略 AIディスカッション</title>

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- marked.js CDN (Markdownパーサー) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Font Awesome CDN (アイコン) -->
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
          integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
          crossorigin="anonymous"
          referrerpolicy="no-referrer"/>

    <!-- スタイル定義 -->
    <style>
        /* Interフォントの読み込み */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            display: flex; /* APIキー画面を中央寄せするため */
            flex-direction: column;
            height: 100vh;
        }

        /* チャットインターフェースが有効になったら高さレイアウトを通常表示に */
        body.chat-active {
            display: block;
        }

        /* APIキー入力画面を全画面に広げる */
        #api-key-screen {
            flex-grow: 1;
        }

        /* チャットスクロールバー */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }
        #chat-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        #chat-container::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }
        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* レポートモーダルのスクロールバー */
        #report-content::-webkit-scrollbar {
            width: 6px;
        }
        #report-content::-webkit-scrollbar-track {
            background: #f8fafc;
        }
        #report-content::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        /* チャットバブル */
        .chat-bubble {
            max-width: 80%;
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        .chat-technician {
            background-color: #3b82f6; /* blue-500 */
            color: #ffffff;
            border-bottom-right-radius: 0.25rem;
            align-self: flex-end;
        }

        .chat-chatgpt {
            background-color: #e5e7eb; /* gray-200 */
            color: #1f2937; /* gray-800 */
            border-bottom-left-radius: 0.25rem;
            align-self: flex-start;
        }

        .chat-gemini {
            background-color: #f3e8ff; /* purple-100 */
            color: #1f2937; /* gray-800 */
            border-bottom-left-radius: 0.25rem;
            align-self: flex-start;
        }

        /* レポート内 markdown スタイル */
        #report-output h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.25rem;
        }
        #report-output h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        #report-output h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
        }
        #report-output ul {
            list-style-type: disc;
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
        }
        #report-output ol {
            list-style-type: decimal;
            margin-left: 1.5rem;
            margin-bottom: 0.5rem;
        }
        #report-output p {
            margin-bottom: 0.5rem;
        }
        #report-output strong {
            font-weight: 600;
        }
        #report-output code {
            background-color: #f3f4f6;
            padding: 0.1rem 0.25rem;
            border-radius: 0.25rem;
            font-family: monospace;
        }

        /* マイクボタン録音中アニメーション */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }
        .recording {
            animation: pulse 1.5s infinite;
            background-color: #ef4444; /* red-500 */
            color: #ffffff;
        }

        /* タイピングカーソル */
        .typing-cursor {
            display: inline-block;
            font-weight: 300;
            color: #94a3b8;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 antialiased">

    <!-- APIキー入力画面 -->
    <div id="api-key-screen"
         class="flex flex-col items-center justify-center w-full h-full p-4 bg-gray-100">
        <div class="w-full max-w-md p-8 bg-white rounded-lg shadow-xl border border-gray-200">
            <h2 class="text-2xl font-bold text-center text-gray-800 mb-6">
                <i class="fa-solid fa-key text-blue-500"></i>
                APIキーを入力
            </h2>
            <p class="text-sm text-gray-600 mb-6 text-center">
                議論を開始するには、
                <span class="font-semibold text-gray-800">Gemini APIキー</span>
                を入力してください。<br>
                ChatGPT APIキーは任意で、画面上の「ChatGPT役」の表現用です。
            </p>

            <form id="api-key-form" class="space-y-4">
                <div>
                    <label for="chatgpt-api-key"
                           class="block text-sm font-medium text-gray-700 mb-1">
                        ChatGPT APIキー（任意・表示用）
                    </label>
                    <input type="password"
                           id="chatgpt-api-key"
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-green-500"
                           placeholder="sk-...">
                </div>

                <div>
                    <label for="gemini-api-key"
                           class="block text-sm font-medium text-gray-700 mb-1">
                        Gemini APIキー（必須・実通信）
                    </label>
                    <input type="password"
                           id="gemini-api-key"
                           class="w-full px-3 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500"
                           placeholder="AIzaSy...">
                </div>

                <p id="api-error"
                   class="text-red-500 text-sm text-center hidden pt-2">
                    Gemini APIキーを入力してください。
                </p>

                <button type="submit"
                        id="start-button"
                        class="w-full bg-blue-500 text-white font-semibold py-3 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors duration-200">
                    議論を開始する
                    <i class="fa-solid fa-arrow-right ml-2"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- チャットインターフェース -->
    <div id="chat-interface" class="hidden flex-col h-screen">
        <!-- ヘッダー -->
        <header class="bg-white shadow-md w-full p-4 border-b border-gray-200">
            <h1 class="text-xl md:text-2xl font-bold text-gray-800 text-center">
                <i class="fa-solid fa-flask-vial text-blue-500"></i>
                材料研究開発戦略 AIディスカッション
            </h1>
        </header>

        <!-- メイン -->
        <main class="flex-1 flex flex-col overflow-hidden p-4 md:p-6 lg:p-8">
            <!-- チャットコンテナ -->
            <div id="chat-container"
                 class="flex-1 overflow-y-auto bg-white p-4 md:p-6 rounded-lg shadow-inner border border-gray-200 flex flex-col space-y-4">
            </div>

            <!-- ローディングインジケーター -->
            <div id="loading-indicator"
                 class="hidden text-center p-4 items-center justify-center space-x-2 text-gray-500">
                <svg class="animate-spin h-5 w-5 text-blue-500"
                     xmlns="http://www.w3.org/2000/svg"
                     fill="none"
                     viewBox="0 0 24 24">
                    <circle class="opacity-25"
                            cx="12" cy="12" r="10"
                            stroke="currentColor"
                            stroke-width="4"></circle>
                    <path class="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V2C5.373 2 2 5.373 2 10h2zm2 5.291A7.962 7.962 0 014 12H2c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>AIが応答を生成中です...</span>
            </div>

            <!-- マイクステータス -->
            <div id="mic-status"
                 class="hidden text-center p-2 text-red-500 font-medium">
                <i class="fa-solid fa-microphone-lines animate-pulse"></i>
                録音中...
            </div>

            <!-- 入力エリア -->
            <div class="bg-white p-4 md:p-6 mt-4 rounded-lg shadow-md border border-gray-200">
                <div class="flex items-start space-x-2 md:space-x-4">
                    <textarea id="message-input"
                              rows="3"
                              class="flex-1 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                              placeholder="議論したい材料領域・社内の強み・将来像、または『議論終了』と入力してください..."></textarea>

                    <button id="send-button"
                            title="送信"
                            class="p-3 h-full bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fa-solid fa-paper-plane fa-fw"></i>
                    </button>

                    <button id="mic-button"
                            title="音声入力"
                            class="p-3 h-full bg-gray-600 text-white rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                        <i id="mic-icon" class="fa-solid fa-microphone fa-fw"></i>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <!-- レポート生成モーダル -->
    <div id="report-modal"
         class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center p-4 z-50 hidden transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-xl w-full max-w-3xl h-full max-h-[90vh] flex flex-col">
            <!-- ヘッダー -->
            <div class="flex justify-between items-center p-5 border-b border-gray-200">
                <h2 class="text-xl font-semibold text-gray-800">
                    <i class="fa-solid fa-file-alt text-purple-600"></i>
                    戦略サマリーレポート
                </h2>
                <button id="close-report-button"
                        class="text-gray-400 hover:text-gray-600 focus:outline-none">
                    <i class="fa-solid fa-times fa-xl"></i>
                </button>
            </div>

            <!-- コンテンツ -->
            <div id="report-content" class="flex-1 p-6 overflow-y-auto">
                <div id="report-loading" class="text-center py-10">
                    <svg class="animate-spin h-8 w-8 text-purple-600 mx-auto"
                         xmlns="http://www.w3.org/2000/svg"
                         fill="none"
                         viewBox="0 0 24 24">
                        <circle class="opacity-25"
                                cx="12" cy="12" r="10"
                                stroke="currentColor"
                                stroke-width="4"></circle>
                        <path class="opacity-75"
                              fill="currentColor"
                              d="M4 12a8 8 0 018-8V2C5.373 2 2 5.373 2 10h2zm2 5.291A7.962 7.962 0 014 12H2c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <p class="mt-4 text-gray-600 font-medium">
                        Geminiが議論を分析し、レポートを作成しています...
                    </p>
                </div>
                <div id="report-output" class="prose max-w-none"></div>
            </div>

            <!-- フッター -->
            <div class="p-4 border-t border-gray-200 bg-gray-50 rounded-b-lg">
                <p class="text-sm text-gray-500 text-center">
                    <i class="fa-solid fa-lightbulb"></i>
                    このレポートはAIによって生成されました。
                </p>
            </div>
        </div>
    </div>

    <!-- JavaScript（モジュール） -->
    <script type="module">
        // ================================
        // 定数・DOM参照
        // ================================
        const GEMINI_MODEL_ID = 'gemini-2.5-flash'; // 後世もわかりやすくモデルを一元管理
        const TYPING_SPEED_MS = 20;
        const END_KEYWORDS = ['議論終了', '議論をおわる', '終了します', 'レポート作成', 'おわり'];

        // APIキー画面
        const apiKeyScreen = document.getElementById('api-key-screen');
        const apiKeyForm = document.getElementById('api-key-form');
        const chatGptApiKeyInput = document.getElementById('chatgpt-api-key');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const apiError = document.getElementById('api-error');

        // チャット画面
        const chatInterface = document.getElementById('chat-interface');
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const micButton = document.getElementById('mic-button');
        const micIcon = document.getElementById('mic-icon');
        const micStatus = document.getElementById('mic-status');
        const loadingIndicator = document.getElementById('loading-indicator');

        // レポートモーダル
        const reportModal = document.getElementById('report-modal');
        const closeReportButton = document.getElementById('close-report-button');
        const reportLoading = document.getElementById('report-loading');
        const reportOutput = document.getElementById('report-output');

        // 状態
        let userProvidedGeminiKey = '';
        let uiHistory = [];      // 画面表示用
        let apiHistory = [];     // Gemini API に渡す contents: [{role, parts:[{text}]}...]
        let isAIBusy = false;
        let isRecording = false;
        let discussionEnded = false;

        // ================================
        // 音声認識（Web Speech API）
        // ================================
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'ja-JP';
            recognition.interimResults = false;
            recognition.continuous = false;

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                messageInput.value = transcript;
                stopRecording();
            };

            recognition.onend = () => {
                if (isRecording) stopRecording();
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                micStatus.textContent = `エラー: ${event.error}`;
                micStatus.classList.remove('hidden');
                setTimeout(() => micStatus.classList.add('hidden'), 3000);
                stopRecording();
            };
        } else {
            micButton.disabled = true;
            micButton.title = 'お使いのブラウザは音声認識をサポートしていません';
        }

        // ================================
        // システムプロンプト定義
        // （Gemini APIの systemInstruction に渡す Content 形式）
        // ================================
        const systemPromptChatGPT = {
            role: 'user',
            parts: [{
                text: [
                    'あなたは材料研究開発の「シーズドリブン」担当AIアシスタント「ChatGPT」役です。',
                    '1. 技術者が指定した材料領域の先端・先行研究と科学的エビデンスを整理する。',
                    '2. 最新に至る技術史・主要ブレークスルー・代表的研究/企業/プロジェクトを短く示す。',
                    '3. 技術者が示す社内の強み（技術・設備・ノウハウ・特許）を踏まえ、それを活用しうる研究トピックを具体的に提案する。',
                    '4. シーズ起点で仮説と根拠を提示しつつ、Geminiや技術者と対話的に探索を深める。',
                    '日本語で、箇条書きや小見出しを活用し、簡潔かつ構造的に回答してください。'
                ].join('\n')
            }]
        };

        const systemPromptGemini = {
            role: 'user',
            parts: [{
                text: [
                    'あなたは材料研究開発の「ニーズドリブン」担当AIアシスタント「Gemini」役です。',
                    '1. 技術者の将来像・事業ビジョンを深掘りし、社会課題・規制・市場トレンド・地政学・環境要請を踏まえて解像度高く整理する。',
                    '2. 対象材料技術がどの産業・どの顧客・どの利用シーンで使われるかを具体化する。',
                    '3. 導入価値、採用障壁、競合状況、自社がとり得るポジションを明確化する。',
                    '4. ChatGPT役のシーズ提案と社内強みを統合し、現実的かつチャレンジングな方向性を提示する。',
                    '日本語で、構造化しつつも一つに固定しない複数案を示し、必要に応じて技術者へ問いかけてください。'
                ].join('\n')
            }]
        };

        const systemPromptReport = {
            role: 'user',
            parts: [{
                text: [
                    'あなたは材料・化学系に精通した技術戦略コンサルタントです。',
                    '「技術者」「ChatGPT（シーズ担当）」「Gemini（ニーズ担当）」三者の全対話履歴をもとに、以下をMarkdownで出力してください。',
                    '1. 議論要約：流れ・主要論点・重要示唆を統合。',
                    '2. 新テーマ/新プロジェクト案：3〜7件。それぞれについて背景、狙う価値、主要技術要素、社内強みとの整合、想定顧客/市場、TRLとタイムライン、主要リスクを記載。',
                    '3. 今後3〜6ヶ月のネクストステップ：具体アクション（調査、PoC、連携先検討、体制構築など）と優先度。',
                    '経営層・研究開発責任者がすぐに意思決定に使える粒度で、簡潔かつ論理的にまとめてください。'
                ].join('\n')
            }]
        };

        // ================================
        // 初期処理
        // ================================
        window.addEventListener('load', () => {
            const savedGptKey = localStorage.getItem('chatgptApiKey');
            const savedGeminiKey = localStorage.getItem('geminiApiKey');
            if (savedGptKey) chatGptApiKeyInput.value = savedGptKey;
            if (savedGeminiKey) geminiApiKeyInput.value = savedGeminiKey;
        });

        apiKeyForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const gptKey = chatGptApiKeyInput.value.trim();
            const geminiKey = geminiApiKeyInput.value.trim();

            if (!geminiKey) {
                apiError.classList.remove('hidden');
                return;
            }
            apiError.classList.add('hidden');

            if (gptKey) {
                localStorage.setItem('chatgptApiKey', gptKey);
            }
            localStorage.setItem('geminiApiKey', geminiKey);
            userProvidedGeminiKey = geminiKey;

            apiKeyScreen.classList.add('hidden');
            chatInterface.classList.remove('hidden');
            chatInterface.classList.add('flex');
            document.body.classList.add('chat-active');

            initializeChat();
        });

        sendButton.addEventListener('click', () => {
            handleUserInput().catch(console.error);
        });

        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleUserInput().catch(console.error);
            }
        });

        micButton.addEventListener('click', () => {
            if (!recognition) return;
            isRecording ? stopRecording() : startRecording();
        });

        closeReportButton.addEventListener('click', () => {
            reportModal.classList.add('hidden');
        });

        // ================================
        // チャット初期化
        // ================================
        async function initializeChat() {
            const msg1 = '技術者の方、こんにちは。私はシーズドリブン担当の ChatGPT 役です。まず、今回フォーカスしたい材料研究開発領域を教えてください。';
            const msg2 = '私はニーズドリブン担当の Gemini 役です。将来像（市場・社会・環境・顧客）や御社の強みも併せて共有いただけると、出口戦略まで一気通貫で整理できます。';

            await addMessageToUI('ChatGPT', msg1, true);
            uiHistory.push({ speaker: 'ChatGPT', text: msg1 });
            apiHistory.push({ role: 'model', parts: [{ text: msg1 }] });

            await addMessageToUI('Gemini', msg2, true);
            uiHistory.push({ speaker: 'Gemini', text: msg2 });
            apiHistory.push({ role: 'model', parts: [{ text: msg2 }] });
        }

        // ================================
        // 音声ヘルパー
        // ================================
        function startRecording() {
            if (isAIBusy || !recognition) return;
            try {
                recognition.start();
                isRecording = true;
                micButton.classList.add('recording');
                micIcon.classList.replace('fa-microphone', 'fa-stop');
                micStatus.textContent = '録音中...';
                micStatus.classList.remove('hidden');
                messageInput.disabled = true;
                sendButton.disabled = true;
            } catch (e) {
                console.error('Recording start error:', e);
                micStatus.textContent = 'エラー: 録音を開始できませんでした。';
                micStatus.classList.remove('hidden');
                setTimeout(() => micStatus.classList.add('hidden'), 3000);
            }
        }

        function stopRecording() {
            if (!isRecording || !recognition) return;
            recognition.stop();
            isRecording = false;
            micButton.classList.remove('recording');
            micIcon.classList.replace('fa-stop', 'fa-microphone');
            micStatus.classList.add('hidden');
            messageInput.disabled = false;
            sendButton.disabled = false;
        }

        // ================================
        // メインロジック（ユーザー入力処理）
        // ================================
        async function handleUserInput() {
            if (discussionEnded) {
                await addMessageToUI('System', '議論はすでに終了しています。新たに始める場合はページをリロードしてください。', false);
                return;
            }

            const message = messageInput.value.trim();
            if (!message || isAIBusy) return;

            setLoading(true);

            try {
                // ユーザーメッセージ表示（ストリーミングなし）
                await addMessageToUI('Technician', message, false);
                messageInput.value = '';

                uiHistory.push({ speaker: 'Technician', text: message });
                apiHistory.push({ role: 'user', parts: [{ text: message }] });

                // 終了キーワード判定
                if (END_KEYWORDS.some((kw) => message.includes(kw))) {
                    await generateReport();
                    discussionEnded = true;
                    return;
                }

                // --- ChatGPT役（シーズ側） ---
                const chatgptReply = await callGeminiApi(systemPromptChatGPT, apiHistory);
                await addMessageToUI('ChatGPT', chatgptReply, true);
                uiHistory.push({ speaker: 'ChatGPT', text: chatgptReply });
                apiHistory.push({ role: 'model', parts: [{ text: chatgptReply }] });

                // --- Gemini役（ニーズ側）へのブリッジ ---
                const bridgePrompt = '(上記のChatGPT役によるシーズ観点の分析を踏まえて、ニーズ・市場・社会・顧客視点から補完・対案を提示してください。)';
                apiHistory.push({ role: 'user', parts: [{ text: bridgePrompt }] });

                // --- Gemini役（ニーズ側） ---
                const geminiReply = await callGeminiApi(systemPromptGemini, apiHistory);
                await addMessageToUI('Gemini', geminiReply, true);
                uiHistory.push({ speaker: 'Gemini', text: geminiReply });
                apiHistory.push({ role: 'model', parts: [{ text: geminiReply }] });

            } catch (error) {
                console.error('AI response chain error:', error);
                const msg = String(error.message || error);
                const friendly =
                    msg.includes('403')
                        ? 'エラー: APIリクエストが禁止されました (403)。Gemini APIキーやAPI有効化設定をご確認ください。'
                        : `エラーが発生しました: ${msg}`;
                await addMessageToUI('System', friendly, false);
            } finally {
                setLoading(false);
            }
        }

        // ================================
        // レポート生成
        // ================================
        async function generateReport() {
            reportModal.classList.remove('hidden');
            reportLoading.classList.remove('hidden');
            reportOutput.innerHTML = '';

            try {
                let historyForReport = [...apiHistory];

                // 直前が "議論終了" などの user メッセージなら除外
                if (historyForReport.length > 0 &&
                    historyForReport[historyForReport.length - 1].role === 'user') {
                    historyForReport.pop();
                }

                // レポート生成依頼を末尾に追加（必ず role:user で終わらせる）
                historyForReport.push({
                    role: 'user',
                    parts: [{
                        text: '(上記が三者による全議論履歴です。指定した要件に従い、戦略サマリーレポートを作成してください。)'
                    }]
                });

                const reportText = await callGeminiApi(systemPromptReport, historyForReport);

                const html = (typeof marked !== 'undefined' && typeof marked.parse === 'function')
                    ? marked.parse(reportText)
                    : reportText.replace(/\n/g, '<br>');

                reportOutput.innerHTML = html;
                reportLoading.classList.add('hidden');
            } catch (error) {
                console.error('Report generation error:', error);
                const msg = String(error.message || error);
                reportOutput.innerHTML =
                    `<p class="text-red-500">レポート生成中にエラーが発生しました: ${msg}</p>`;
                reportLoading.classList.add('hidden');
            }
        }

        // ================================
        // Gemini API 呼び出し
        // ================================
        async function callGeminiApi(systemInstruction, history) {
            if (!userProvidedGeminiKey) {
                throw new Error('Gemini APIキーが設定されていません。');
            }

            if (!Array.isArray(history) || history.length === 0) {
                throw new Error('内部エラー: 会話履歴が空です。');
            }

            if (history[history.length - 1].role !== 'user') {
                console.error('API call history error: Last role is not "user".', history);
                throw new Error('内部エラー: API履歴の形式が不正です（末尾はuserである必要があります）。');
            }

            const url =
                `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(
                    GEMINI_MODEL_ID
                )}:generateContent?key=${encodeURIComponent(userProvidedGeminiKey)}`;

            const payload = {
                contents: history,
                systemInstruction,
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 4096
                }
            };

            const maxRetries = 5;
            let delay = 800;

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);

                        if (response.status === 403) {
                            throw new Error('APIリクエスト失敗 (403)。キーまたはプロジェクト設定を確認してください。');
                        }
                        throw new Error(`APIリクエスト失敗 (ステータス: ${response.status})`);
                    }

                    const result = await response.json();

                    const candidate = result?.candidates?.[0];
                    const parts = candidate?.content?.parts;

                    if (Array.isArray(parts) && parts.length > 0) {
                        const text = parts.map(p => p.text || '').join('').trim();
                        if (text) return text;
                    }

                    if (candidate?.finishReason === 'SAFETY') {
                        throw new Error('応答が安全性設定によりブロックされました。プロンプト内容を見直してください。');
                    }

                    console.warn('Unexpected API response structure:', result);
                    throw new Error('AIから有効な応答を取得できませんでした。');

                } catch (error) {
                    console.warn(`Attempt ${attempt} failed: ${error.message || error}`);
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                }
            }
        }

        // ================================
        // UIヘルパー
        // ================================
        /**
         * メッセージをチャットUIに追加
         * @param {'Technician'|'ChatGPT'|'Gemini'|'System'} speaker
         * @param {string} message
         * @param {boolean} streamEffect - AIメッセージをタイプ風表示するか
         */
        async function addMessageToUI(speaker, message, streamEffect = false) {
            const wrapper = document.createElement('div');
            wrapper.classList.add('chat-bubble', 'flex', 'flex-col');

            let label = '';
            let iconClass = '';
            let bubbleClass = '';

            switch (speaker) {
                case 'Technician':
                    label = '技術者 (あなた)';
                    iconClass = 'fa-solid fa-user';
                    bubbleClass = 'chat-technician';
                    break;
                case 'ChatGPT':
                    label = 'ChatGPT (シーズ担当)';
                    iconClass = 'fa-solid fa-brain text-green-600';
                    bubbleClass = 'chat-chatgpt';
                    break;
                case 'Gemini':
                    label = 'Gemini (ニーズ担当)';
                    iconClass = 'fa-solid fa-globe text-purple-600';
                    bubbleClass = 'chat-gemini';
                    break;
                case 'System':
                default:
                    label = 'システム';
                    iconClass = 'fa-solid fa-triangle-exclamation text-red-500';
                    bubbleClass = 'chat-chatgpt';
                    break;
            }

            wrapper.classList.add(bubbleClass);

            const header = document.createElement('div');
            header.classList.add(
                'flex', 'items-center', 'space-x-2', 'mb-1',
                'font-semibold', 'text-xs'
            );
            header.classList.add(speaker === 'Technician' ? 'text-blue-100' : 'text-gray-700');
            header.innerHTML = `<i class="${iconClass}"></i><span>${label}</span>`;

            const content = document.createElement('div');
            content.classList.add('message-content', 'text-sm', 'leading-relaxed');

            wrapper.appendChild(header);
            wrapper.appendChild(content);
            chatContainer.appendChild(wrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            const safeMessage = message || '';

            // ストリーミング風エフェクト（AI用）
            if (streamEffect && safeMessage.length > 0) {
                const cursor = document.createElement('span');
                cursor.classList.add('typing-cursor');
                cursor.textContent = '▌';

                const textNode = document.createTextNode('');
                content.appendChild(textNode);
                content.appendChild(cursor);

                for (const ch of safeMessage) {
                    textNode.nodeValue += ch;
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    await new Promise(res => setTimeout(res, TYPING_SPEED_MS));
                }

                content.removeChild(cursor);

                const html = (typeof marked !== 'undefined' && typeof marked.parse === 'function')
                    ? marked.parse(safeMessage)
                    : safeMessage.replace(/\n/g, '<br>');
                content.innerHTML = html;
            } else {
                const html = (typeof marked !== 'undefined' && typeof marked.parse === 'function')
                    ? marked.parse(safeMessage)
                    : safeMessage.replace(/\n/g, '<br>');
                content.innerHTML = html;
            }

            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function setLoading(isLoading) {
            isAIBusy = isLoading;
            if (isLoading) {
                loadingIndicator.classList.remove('hidden');
                loadingIndicator.classList.add('flex');
                sendButton.disabled = true;
                micButton.disabled = true;
                messageInput.disabled = true;
            } else {
                loadingIndicator.classList.add('hidden');
                loadingIndicator.classList.remove('flex');
                sendButton.disabled = false;
                micButton.disabled = !recognition;
                messageInput.disabled = false;
                messageInput.focus();
            }
        }
    </script>
</body>
</html>
